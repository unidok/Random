package me.unidok.random

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import kotlin.random.Random

@Composable
fun RandomNumberGenerator() {
    var min by remember { mutableStateOf("1") }
    var errorMin by remember { mutableStateOf<String?>(null) }
    var max by remember { mutableStateOf("25") }
    var errorMax by remember { mutableStateOf<String?>(null) }
    var isInteger by remember { mutableStateOf(true) }
    var generated by remember { mutableStateOf<String?>(null) }

    fun updateMin(input: String) {
        min = input
        errorMin = null
        if (isInteger) {
            try {
                val min = input.toInt()
                if (errorMax == null && min >= max.toInt()) {
                    errorMin = "Нижняя граница должна быть меньше верхней"
                }
            } catch (_: NumberFormatException) {
                errorMin = "Неверное целое число"
            }
        } else {
            try {
                val min = input.toDouble()
                if (errorMax == null && min >= max.toDouble()) {
                    errorMin = "Нижняя граница должна быть меньше верхней"
                }
            } catch (_: NumberFormatException) {
                errorMin = "Неверное число"
            }
        }
    }

    fun updateMax(input: String) {
        max = input
        errorMax = null
        if (isInteger) {
            try {
                val max = input.toInt()
                if (errorMin == null && max <= min.toInt()) {
                    errorMax = "Верхняя граница должна быть больше нижней"
                }
            } catch (_: NumberFormatException) {
                errorMax = "Неверное целое число"
            }
        } else {
            try {
                val max = input.toDouble()
                if (errorMin == null && max <= min.toDouble()) {
                    errorMax = "Верхняя граница должна быть больше нижней"
                }
            } catch (_: NumberFormatException) {
                errorMax = "Неверное число"
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        ResultField(
            result = generated?.let { "Число: $it" },
            style = MaterialTheme.typography.h4,
            onClear = { generated = null }
        )

        Spacer(modifier = Modifier.height(40.dp))

        NumberField(
            value = min,
            error = errorMin,
            onValueChange = {
                updateMin(it)
                updateMax(max)
            },
            label = { Text("Введите нижнюю границу") }
        )

        Spacer(modifier = Modifier.height(8.dp))

        NumberField(
            value = max,
            error = errorMax,
            onValueChange = {
                updateMax(it)
                updateMin(min)
            },
            label = { Text("Введите верхнюю границу") }
        )

        Spacer(modifier = Modifier.height(16.dp))

        OutlinedButton(
            onClick = {
                isInteger = !isInteger
                updateMin(min)
                updateMax(max)
            }
        ) {
            Text(if (isInteger) "Целое" else "Дробное")
        }

        Spacer(modifier = Modifier.height(16.dp))

        Button(onClick = onClick@ {
            generated = if (isInteger) {
                if (errorMin != null || errorMax != null) return@onClick
                Random.nextInt(min.toInt(), max.toInt() + 1).toString()
            } else {
                if (errorMin != null || errorMax != null) return@onClick
                String.format("%.2f", Random.nextDouble(min.toDouble(), max.toDouble()))
            }
        }) {
            Text("Сгенерировать случайное число")
        }
    }
}

@Composable
fun NumberField(
    value: String,
    error: String?,
    onValueChange: (String) -> Unit,
    label: @Composable () -> Unit
) {
    TextField(
        value = value,
        onValueChange = onValueChange,
        label = label,
        modifier = Modifier
            .width(250.dp),
        isError = error != null,
        singleLine = true
    )

    error?.let {
        Text(
            text = it,
            color = MaterialTheme.colors.error,
            style = MaterialTheme.typography.caption,
            modifier = Modifier.padding(top = 8.dp)
        )
    }
}